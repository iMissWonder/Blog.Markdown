---
title: 如何用VerilogHDL编写一个单周期MIPS32CPU（一）
date: 2016-05-01 17:31:49
tags: 计算机原理与汇编
---
题目：用VerilogHDL完成单周期处理器开发。

>单周期处理器由**datapath(数据通路)和controller(控制器)** 组成。

> a)	数据通路由如下module组成：
> ** PC(程序计数器)、NPC(NextPC计算单元)、GPR (通用寄存器组，也称为寄存器文件、寄存器堆)、ALU(算术逻辑单元)、EXT(扩展单元)、IM(指令存储器)、DM(数据存储器)。**
> b)	IM：容量为4KB(32bit×1024字)。
> c)	DM：容量为4KB(32bit×1024字)。

本系列文章内容前四篇内容摘自《自己动手写CPU》，后三篇为原创。在此十分感谢作者把书无偿发布到博客上，为我们提供了宝贵的资源！

需要环境：
1.ModelSim 10.1a
2.测试程序Mars（需要Java环境）

第一篇为复习VerilogHDL的基本语法、结构。

<!-- more -->
## VerilogHDL的基本语法
### Verilog HDL中模块的结构

Verilog程序的基本设计单元是“模块”（Module），一个模块有其特定的结构，如图2-6所示。Verilog的模块完全定义在module与endmodule关键字之间，每个模块包括四个主要部分：**模块声明、端口定义、数据类型说明和逻辑功能描述。**

```
module<模块名>(
      <端口>
      <端口>        模块声明
      ……
);

      <端口定义>

      <数据类型说明>

      <逻辑功能描述>
endmodule
```

如下是一个实现32位加法器的模块。有两个输入信号in1、in2，两者相加的结果通过out输出。
```
module add32(in1, in2, out); // 模块声明
input in1, in2; // 端口定义，此处是输入端口
output out; // 端口定义，此处是输出端口
wire[31:0] in1, in2, out; // 数据类型说明，此处都是wire型
assign out = in1 + in2; // 逻辑功能描述
endmodule
```
下面结合该加法器的例子，对Module的基本结构进行说明。

#### 1.模块声明
模块声明包括模块名字，以及输入、输出端口列表，其格式如下。
```
module 模块名(端口1, 端口2, 端口3……);
```

#### 2.端口定义
明确说明模块端口的方向（输入、输出、双向等），其格式如下。
```
input 端口1, 端口2, 端口3 ……; // 输入端口
output 端口1, 端口2, 端口3 ……; // 输出端口
inout 端口1, 端口2, 端口3 ……; // 双向端口
```

#### 3.数据类型说明
对模块中所有用到的信号（包括端口信号、节点信号等）都必须进行数据类型的定义。Verilog HDL提供了各种信号类型，下面是几种定义信号类型的例子。各数据类型的具体含义将在2.5.2节详述。
```
reg a; // 定义信号a的数据类型为reg型
wire[31:0] out ; // 定义信号out的数据类型为32位wire型
```

对于端口，可以将数据类型说明与端口定义放在一条语句中完成，于是，上文的32位加法器可以改为如下形式。

```
module add32(in1, in2, out);
input wire[31:0] in1, in2; // 将端口定义与类型说明放在一条语句
output wire[31:0] out;
assign out = in1 + in2;
endmodule
```
对于端口，还可以将端口定义、数据类型说明都放在模块声明中，而不再放在模块内部，于是，上文的32位加法器还可以改为如下形式，更为简便。
```
// 将端口定义、数据类型说明放在模块声明中
module add32(input wire[31:0] in1,
input wire[31:0] in2,
output wire[31:0] out);
assign out = in1 + in2;
endmodule
```

#### 4.逻辑功能描述
模块中最核心的部分就是逻辑功能描述，可以有多种方法在模块中描述和定义逻辑功能。几种基本方法如下。
> 用assign持续赋值语句定义
> 用always过程块定义
> 调用元件（也称为元件例化）

## Verilog HDL基本要素
### 常量
Verilog中的常量（Constant）有三种：**整数**、**实数**、**字符串**。在OpenMIPS的实现过程中只使用到了整数常量，所以，此处也仅介绍整数常量。

一些整数常数的例子如下。
```
8'b11000101 // 宽度为8位的二进制数，数值为11000101，等于十进制的197
8'h8a // 宽度为8位的十六进制数，数值为8a，等于十进制的138
5'o27 // 宽度为5位的八进制数，数值为27，等于十进制的23
4'd10 // 宽度为4位的十进制数，数值为10
```
如果没有明确指明进制，那么默认是十进制。

### 变量声明与数据类型
Verilog中变量声明的格式如图所示。只有数据类型、变量名是必要的，其他部分都可以省略。如果省略符号和位宽，那么根据数据类型设置为默认值。如果省略元素数，那么默认声明元素数为1。

![statement](http://7xt50p.com1.z0.glb.clouddn.com/post/cpu/1/2.png)

数据类型可以是net型、variable型，分别介绍如下。
#### net型变量
net型相当于硬件电路中各种物理连接，其特点是输出的值紧跟输入值的变化而变化。net型变量包括多种类型。
在实现OpenMIPS处理器的时候 **只使用到了其中的wire类型**。
> wire是最常用的net型变量，Verilog HDL模块中的输入、输出信号在没有明确指定数据类型时，都被默认为wire型。wire型信号可以用作任何表达式的输入，也可以用作assign语句和实例元件的输出，如前文中的32位加法器对out信号的赋值。对于综合器而言，wire型变量的取值可为0、1、X、Z，其中0表示低电平、逻辑0；1表示高电平、逻辑1；X表示不确定或未知的逻辑状态；Z表示高阻态。如果没有赋值，默认为高阻态Z。

#### variable型变量
variable型变量是可以保存上次写入数据的数据类型，一般对应硬件上的一个触发器或锁存器等存储元件，但并不是绝对的，在综合器综合的时候，会根据其被赋值的情况来具体确定是映射成连线还是映射为存储元件。variable型变量也包括多种类型。
在实现OpenMIPS处理器的时候 **只使用到了其中的reg类型**。
variable型变量必须在过程语句（initial或always）中实现赋值，这种赋值方式称为过程赋值。

### 向量
图2-8变量声明格式中的位宽如果为1，那么对应的变量为标量，如果不为1，那么对应的变量为向量，默认为标量。向量的位宽用下面的形式定义。
```
[MSB : LSB]
```
冒号左边的数字表示向量的最高有效位MSB（Most Significant Bit），冒号右边的数字表示向量的最低有效位LSB（Least Significant Bit）。
```
wire [3:0] bus; // 4位的wire型向量bus，其中bus[3]是最高位，bus[0]是最低位
reg [31:5] ra; // 27位的reg型向量ra，其中ra[31]是最高位，ra[5]是最低位
reg [0:7] rc; // 8位的reg型向量rc，其中rc[0]是最高位，rc[7]是最低位
```
向量有两种，一种是向量类向量，一种是标量类向量，可以使用关键字区分，如下。
```
wire vectored [7:0] databus; // 使用关键字vectored，表示是向量类向量
reg scalared [31:0] rega; // 使用关键字scalared，表示是标量类向量
```
如果没有明确指出，那么默认是标量类向量。
实现时 **只用到了标量类向量**，对标量类向量可以任意选中其中的一位或相邻几位，分别称为 **位选择（bit-select）和域选择（part-select）**。
```
A = rega[6]; // 位选择，将向量rega的其中一位赋值给变量A
B = rega[5:2]; // 域选择，将向量rega的第5、4、3、2位赋值给变量B
```
在OpenMIPS的实现过程中，**使用到了存储器(寄存器)**，存储器可看做是二维的向量。如下就是一个存储器的定义，定义了一个深度为64，每个元素宽度为32bit的存储器。
reg [31:0] mem[63:0]; // mem是深度为64，字长为32bit的存储器

### 运算符
Verilog HDL中定义的运算符包括：算术运算符、逻辑运算符、位运算符、关系运算符、等式运算符、缩位运算符、移位运算符、条件运算符和位拼接运算符。
![statement](http://7xt50p.com1.z0.glb.clouddn.com/post/cpu/1/3.png)

#### 等式运算符中的“==”与“===”的区别
对于“==”运算，参与比较的两个操作数必须逐位相等，其结果才为1，如果某些值是不定态X或高阻态Z，那么得到的结果是不定值X；而对于“===”运算，则要求对参与运算的操作数中为不定态X或高阻态Z的位也进行比较，两个操作数必须完全一致，其结果才为1，否则结果为0。例如。
```
reg [4:0] a = 5'b11x01;
reg [4:0] b = 5'b11x01;
```
针对上面的a、b，“a==b”的返回结果为X，而“a===b”的返回结果为1。

#### 缩位运算符与位运算
运算符号、逻辑运算法则都是一样的，但是缩位运算符是对单个操作数进行与、或、异或的递推运算，它放在操作数的前面，能够将一个矢量减为一个标量。例如。
```
reg [3:0] a;
b = &a; // 等效于b = ((a[0] & a[1]) & a[2]) & a[3]
```
而位运算需要对两个操作数按对应位分别进行逻辑运算，例如。
```
wire [3:0] a = 4'b0011;
wire [3:0] b = 4'b0101;
```
那么a&b = 4'b0001，a|b = 4'b0111

#### 位拼接运算符
用来将两个或多个信号的某些位拼接起来。其格式如下。

{比特序列0, 比特序列1,…… }
例如，在进行加法运算时，可将和与进位输出拼接在一起使用。
input [3:0] ina,inb; // 加法输入
output [3:0] sum; // 加法的和
output cout; // 进位
assign {cout, sum} = ina + inb; // 将和与进位拼接在一起
位拼接还可以用来重复信号的某些位，其格式如下。
```
{重复次数{被重复数据}}
```
利用上面的功能，可以实现对信号的符号扩展，例如。
```
//将Data的符号位进行扩展,s_data = {Data[7],Data[7],Data[7],Data[7],Data}
wire [7:0] Data;
wire [11:0] s_data;
s_data = {{4{Data[7]}},Data};
```
#### 运算符的优先级
![statement](http://7xt50p.com1.z0.glb.clouddn.com/post/cpu/1/1.png)
